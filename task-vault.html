<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Task Vault - DiceForge Studios</title>
  <link rel="stylesheet" href="tribute-lands.css">
  <link rel="stylesheet" href="vault-common.css">
  <script src="tool-navigation.js"></script>
</head>
<body>
  <header>
    <div>
      <h1>TRIBUTE LANDS â€” TASK VAULT</h1>
      <div class="subtitle">DiceForge Studios Production System</div>
    </div>
    <div id="headerButtons" style="display:flex;align-items:center;gap:8px;">
      <!-- Populated by integration script -->
    </div>
    <div style="display:flex;gap:8px;margin-right:20px;">
      <button class="btn sm" onclick="window.location.href='foundry'" title="Production Dashboard">ğŸ­ Foundry</button>
      <button class="btn sm" onclick="window.location.href='character-vault'" title="Character Database">ğŸ‘¤ Characters</button>
      <button class="btn sm" onclick="window.location.href='adventure-vault'" title="Adventure Vault">ğŸ­ Adventures</button>
    </div>
    <div class="header-stats">
      <span><span class="stat-num" id="totalTasks">0</span> Tasks</span>
      <span><span class="stat-num" id="criticalTasks">0</span> Critical</span>
      <span><span class="stat-num" id="highTasks">0</span> High</span>
    </div>
    <div id="syncIndicator" style="text-align:right;padding:2px 10px;display:flex;align-items:center;justify-content:flex-end;gap:8px">
      <span id="syncLabel" style="font-size:11px;font-family:monospace;color:var(--text-dim)">â—</span>
      <button onclick="forceRefresh()" style="font-size:10px;padding:1px 6px;background:none;border:1px solid var(--border);color:var(--text-dim);border-radius:3px;cursor:pointer" title="Reload from remote">â†» Refresh</button>
      <button onclick="promptForToken()" id="tokenBtn" style="font-size:10px;padding:1px 6px;background:none;border:1px solid var(--border);color:var(--text-dim);border-radius:3px;cursor:pointer" title="Set GitHub token">ğŸ”‘ Token</button>
    </div>
  </header>

  <div id="breadcrumb">
    <span class="bc-current">Task Vault</span>
  </div>

  <div class="container">
    <div class="sidebar" id="taskSidebar">
      <div class="sidebar-controls">
        <input type="text" id="searchInput" placeholder="Search tasks..." oninput="filterTasks()">
        <div class="filter-row">
          <select id="filterPriority" onchange="filterTasks()">
            <option value="">All Priorities</option>
            <option value="critical">ğŸ”´ Critical</option>
            <option value="high">ğŸŸ¡ High</option>
            <option value="normal">âšª Normal</option>
          </select>
        </div>
      </div>
      
      <div class="task-list" id="taskList">
        <!-- Populated by JavaScript -->
      </div>
      
      <div class="sidebar-footer">
        <button class="btn primary" style="flex: 1;" onclick="createNewTask()">+ New Task</button>
        <button class="btn sm" onclick="exportTasks()">Export</button>
      </div>
    </div>
    
    <div class="main empty-state" id="mainContent">
      Select a task or create a new one
    </div>
  </div>

  <script>
    // Gist configuration
    const GIST_ID = '7fa2d50c458ed95c21a3c6d283f863d6';
    const GIST_TOKEN = localStorage.getItem('diceforge_gist_token') || '';
    const GIST_FILENAME = 'diceforge-tasks.json';
    const CACHE_KEY = 'diceforge_tasks_cache';

    // State
    let allTasks = [];
    let filteredTasks = [];
    let currentTask = null;
    let syncStatus = 'idle';
    let saveTimer = null;

    // Sync status management
    function setSyncStatus(status, label) {
      syncStatus = status;
      const indicator = document.getElementById('syncLabel');
      indicator.textContent = label || 'â—';
      document.getElementById('tokenBtn').style.display = GIST_TOKEN ? 'none' : 'inline-block';
    }

    // Load tasks from Gist
    async function loadTasks() {
      const cached = localStorage.getItem(CACHE_KEY);
      if (cached) {
        try {
          const data = JSON.parse(cached);
          allTasks = data.tasks || [];
          filterTasks();
          updateStats();
        } catch (e) {
          console.error('Cache parse error:', e);
        }
      }

      if (GIST_ID && GIST_TOKEN) {
        try {
          setSyncStatus('saving', 'Loading...');
          const resp = await fetch(`https://api.github.com/gists/${GIST_ID}`, {
            headers: {
              'Authorization': `token ${GIST_TOKEN}`,
              'Accept': 'application/vnd.github.v3+json'
            }
          });

          if (!resp.ok) throw new Error(`GitHub ${resp.status}`);

          const gist = await resp.json();
          const raw = gist.files[GIST_FILENAME]?.content;
          
          if (raw) {
            const data = JSON.parse(raw);
            allTasks = data.tasks || [];
            localStorage.setItem(CACHE_KEY, raw);
            console.log('âœ… Loaded from Gist:', allTasks.length, 'tasks');
          }
          
          setSyncStatus('idle', `${allTasks.length} tasks`);
        } catch (err) {
          console.error('âŒ Gist load failed:', err);
          setSyncStatus('error', 'Load failed');
        }
      } else {
        setSyncStatus('idle', 'Offline mode');
      }

      filterTasks();
      updateStats();
    }

    // Save tasks to Gist
    async function pushToGist() {
      const data = {
        version: '1.0',
        lastModified: new Date().toISOString(),
        lastModifiedBy: 'task-vault',
        taskCount: allTasks.length,
        tasks: allTasks
      };
      localStorage.setItem('tasks_local_backup', JSON.stringify(data));

      if (!GIST_ID || !GIST_TOKEN) return;

      setSyncStatus('saving', 'Saving...');
      
      try {
        const raw = JSON.stringify(data, null, 2);
        const resp = await fetch(`https://api.github.com/gists/${GIST_ID}`, {
          method: 'PATCH',
          headers: {
            'Authorization': `token ${GIST_TOKEN}`,
            'Accept': 'application/vnd.github.v3+json',
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            files: {
              [GIST_FILENAME]: { content: raw }
            }
          })
        });

        if (!resp.ok) throw new Error(`GitHub ${resp.status}`);

        localStorage.setItem(CACHE_KEY, raw);
        console.log('âœ… Gist save success');
        setSyncStatus('idle', `Saved`);
      } catch (err) {
        console.error('âŒ Gist save FAILED:', err);
        setSyncStatus('error', 'Save failed');
      }
    }

    // Queue save (debounced)
    function queueSave() {
      if (saveTimer) clearTimeout(saveTimer);
      saveTimer = setTimeout(() => {
        pushToGist();
        saveTimer = null;
      }, 2000);
    }

    // Force refresh
    async function forceRefresh() {
      localStorage.removeItem(CACHE_KEY);
      await loadTasks();
    }

    // Prompt for token
    function promptForToken() {
      const token = prompt('Enter your GitHub Personal Access Token:');
      if (token) {
        localStorage.setItem('diceforge_gist_token', token);
        location.reload();
      }
    }

    // Filter tasks
    function filterTasks() {
      const priorityFilter = document.getElementById('filterPriority').value;
      const searchTerm = document.getElementById('searchInput').value.toLowerCase();

      filteredTasks = allTasks.filter(task => {
        if (task.completed) return false;
        if (priorityFilter && task.priority !== priorityFilter) return false;
        if (searchTerm) {
          const title = (task.title || '').toLowerCase();
          const desc = (task.description || '').toLowerCase();
          if (!title.includes(searchTerm) && !desc.includes(searchTerm)) return false;
        }
        return true;
      });

      renderTaskList();
    }

    // Render task list in sidebar
    function renderTaskList() {
      const container = document.getElementById('taskList');
      
      if (filteredTasks.length === 0) {
        container.innerHTML = '<div style="padding:20px;text-align:center;color:var(--text-dim)">No tasks found</div>';
        return;
      }

      // Sort by priority then title
      const sorted = [...filteredTasks].sort((a, b) => {
        const priorityOrder = { critical: 0, high: 1, normal: 2 };
        const pDiff = priorityOrder[a.priority] - priorityOrder[b.priority];
        if (pDiff !== 0) return pDiff;
        return a.title.localeCompare(b.title);
      });

      container.innerHTML = sorted.map(task => {
        const selected = currentTask && currentTask.id === task.id ? 'active' : '';
        const priorityIcon = task.priority === 'critical' ? 'ğŸ”´' : task.priority === 'high' ? 'ğŸŸ¡' : 'âšª';
        
        return `
          <div class="task-item priority-${task.priority} ${selected}" onclick="selectTask('${task.id}')">
            <div class="task-name">${task.title}</div>
            <div class="task-meta">${priorityIcon} ${task.priority.charAt(0).toUpperCase() + task.priority.slice(1)}</div>
          </div>
        `;
      }).join('');
    }

    // Select task (show in main panel)
    function selectTask(id) {
      currentTask = allTasks.find(t => t.id === id);
      if (!currentTask) return;

      renderTaskList(); // Update selection
      renderTaskDetail();
    }

    // Render task detail in main panel
    function renderTaskDetail() {
      if (!currentTask) {
        document.getElementById('mainContent').className = 'main empty-state';
        document.getElementById('mainContent').innerHTML = 'Select a task or create a new one';
        return;
      }

      const priorityIcon = currentTask.priority === 'critical' ? 'ğŸ”´' : currentTask.priority === 'high' ? 'ğŸŸ¡' : 'âšª';
      
      document.getElementById('mainContent').className = 'main';
      document.getElementById('mainContent').innerHTML = `
        <div style="max-width: 800px;">
          <div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 20px;">
            <div>
              <h2 style="margin: 0 0 8px 0;">${currentTask.title}</h2>
              <div style="color: var(--text-dim); font-size: 13px;">
                ${priorityIcon} ${currentTask.priority.charAt(0).toUpperCase() + currentTask.priority.slice(1)} Priority
                ${currentTask.created ? ` â€¢ Created: ${new Date(currentTask.created).toLocaleDateString()}` : ''}
              </div>
            </div>
            <div style="display: flex; gap: 8px;">
              <button class="btn sm" onclick="editTask()">âœï¸ Edit</button>
              <button class="btn sm" onclick="completeTask()">âœ“ Complete</button>
            </div>
          </div>

          ${currentTask.description ? `
            <div style="margin-bottom: 20px;">
              <h3 style="font-size: 14px; color: var(--text-dim); margin-bottom: 8px;">DESCRIPTION</h3>
              <div>${currentTask.description}</div>
            </div>
          ` : ''}

          ${currentTask.notes ? `
            <div style="margin-bottom: 20px;">
              <h3 style="font-size: 14px; color: var(--text-dim); margin-bottom: 8px;">NOTES</h3>
              <div style="font-style: italic;">ğŸ’¡ ${currentTask.notes}</div>
            </div>
          ` : ''}
        </div>
      `;
    }

    // Create new task
    function createNewTask() {
      const title = prompt('Task title:');
      if (!title) return;

      const priority = prompt('Priority (critical/high/normal):', 'normal');
      if (!['critical', 'high', 'normal'].includes(priority)) {
        alert('Invalid priority');
        return;
      }

      const newTask = {
        id: `task_${Date.now()}`,
        title: title,
        description: '',
        priority: priority,
        notes: '',
        completed: false,
        created: new Date().toISOString()
      };

      allTasks.unshift(newTask);
      queueSave();
      filterTasks();
      updateStats();
      selectTask(newTask.id);
    }

    // Edit task
    function editTask() {
      if (!currentTask) return;

      const title = prompt('Title:', currentTask.title);
      if (title) currentTask.title = title;

      const description = prompt('Description:', currentTask.description);
      if (description !== null) currentTask.description = description;

      const notes = prompt('Notes:', currentTask.notes);
      if (notes !== null) currentTask.notes = notes;

      const priority = prompt('Priority (critical/high/normal):', currentTask.priority);
      if (priority && ['critical', 'high', 'normal'].includes(priority)) {
        currentTask.priority = priority;
      }

      queueSave();
      filterTasks();
      renderTaskDetail();
    }

    // Complete task (delete)
    function completeTask() {
      if (!currentTask) return;
      if (!confirm(`Delete task: ${currentTask.title}?`)) return;

      allTasks = allTasks.filter(t => t.id !== currentTask.id);
      currentTask = null;
      
      queueSave();
      filterTasks();
      updateStats();
      
      document.getElementById('mainContent').className = 'main empty-state';
      document.getElementById('mainContent').innerHTML = 'Select a task or create a new one';
    }

    // Export tasks
    function exportTasks() {
      const byPriority = {
        critical: allTasks.filter(t => !t.completed && t.priority === 'critical'),
        high: allTasks.filter(t => !t.completed && t.priority === 'high'),
        normal: allTasks.filter(t => !t.completed && t.priority === 'normal')
      };

      let markdown = '# Task Vault Export\n';
      markdown += `Generated: ${new Date().toLocaleString()}\n\n`;
      markdown += `**Total Active:** ${allTasks.filter(t => !t.completed).length}\n\n`;
      markdown += '---\n\n';

      ['critical', 'high', 'normal'].forEach(priority => {
        const tasks = byPriority[priority];
        if (tasks.length === 0) return;

        const icon = priority === 'critical' ? 'ğŸ”´' : priority === 'high' ? 'ğŸŸ¡' : 'âšª';
        markdown += `## ${icon} ${priority.charAt(0).toUpperCase() + priority.slice(1)} Priority\n\n`;
        
        tasks.forEach(task => {
          markdown += `- [ ] **${task.title}**\n`;
          if (task.description) markdown += `  ${task.description}\n`;
          if (task.notes) markdown += `  ğŸ’¡ _${task.notes}_\n`;
          markdown += '\n';
        });
      });

      const blob = new Blob([markdown], { type: 'text/markdown' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'tasks.md';
      a.click();
      URL.revokeObjectURL(url);
    }

    // Update stats
    function updateStats() {
      const active = allTasks.filter(t => !t.completed);
      document.getElementById('totalTasks').textContent = active.length;
      document.getElementById('criticalTasks').textContent = active.filter(t => t.priority === 'critical').length;
      document.getElementById('highTasks').textContent = active.filter(t => t.priority === 'high').length;
    }

    // Initialize
    document.addEventListener('DOMContentLoaded', () => {
      addToolNavigation('task-vault');
      loadTasks();
      setSyncStatus('idle');
    });
  </script>
</body>
</html>
